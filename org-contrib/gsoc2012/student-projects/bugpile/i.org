#+OPTIONS:    H:4 num:nil toc:3 \n:nil @:t ::t |:t ^:{} -:t f:t *:t TeX:t LaTeX:t skip:nil d:(HIDE) tags:not-in-toc
#+STARTUP:    align fold nodlcheck oddeven lognotestate hideblocks
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:       Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+TITLE:      iOrg - interactive Org
#+AUTHOR:     Thorsten Jolitz
#+EMAIL:      tj[at]data-driven[dot]de
#+LANGUAGE:   en
#+STYLE:      <style type="text/css">#outline-container-introduction{ clear:both; }</style>
#+LINK_UP:    index.html
#+LINK_HOME:  http://orgmode.org/worg/
#+EXPORT_EXCLUDE_TAGS: noexport

# #+name: banner
# #+begin_html
#   <div id="subtitle" style="float: center; text-align: center;">
#   <p>
#   A Web-Framework based on <a href="http://orgmode.org/">Org-mode</a> and
#                                 <a href="http://picolisp.com/5000/!wiki?home/">PicoLisp</a>
#   </p>
#   <p>
#   <a href="http://picolisp.com/5000/!wiki?home/">
#   <img src="http://picolisp.com/5000/wiki/logo.png"/>
#   </a>
#   </p>
#   </div>
# #+end_html

/A framework for dynamic webprogramming with GNU Emacs Org-mode/

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: intro
  :END:

iOrg is a pure Org-mode and Emacs web framework with
persistence and versioning through dVCs. It aims at extending
Org-modes static webpublishing capacities with dynamcic components
(like html forms and buttons that allow user interaction) and database
functionality (storing and querying state). 

The web framework abstracts away all of the boilerplate required for
its [[id:lang-tools][components]] to work together, allowing application builders the
freedom to focus on the logic of their particular applications.

* Languages and tools
  :PROPERTIES:
  :CUSTOM_ID: lang-tools
  :END:

| Emacs Lisp  | server side                                      |
| Java Script | client side                                      |
| Elnode      | web server, handles get and post requests        |
| Org-mode    | content storage both database and marked up text |
| DVCS        | data persistence and versioning                  |

* Graphical depiction of the frameworks architecture
:                                                                         Server
:                                                  +-------------------------------------------------------+
:        Client Browser                            |                                                       |
:     +-------------------+                        |  +-------------------+                                |
:     |  Static HTML      |     full pages         |  |   Emacs / Elisp   |   +---------------+  +-------+ |
:     |   Content         | <-----------------+    |  +-------------------+   | Content in    |  |  DVCS | |
:     |                   |       HTML        |    |  |          +------+ |   | flat files    |==|       | |
:     |    +--------------+                   +----+--+----------| Org  |-+-->| on file       |==|       | |
:     |    | inter-mixed  |                        |  | +------+=|      |<+---| system        |==|       | |
:     |    | interactive  |                        |  | |elnode|=+------+ |   |               |==|       | |
:     |    | JS forms,    |  JS requests get/post  |  | |      |          |   |               |  |       | |
:     |    | buttons,     | -----------------------+--+>|      |          |   +---------------+  +-------+ |
:     |    | etc...       |  form data & json      |  | +--+---+     |    |                          ^     |
:     |    |              |                        |  +----+---------+----+                          |     |
:     +----+--------------+                        |       |         |        commit changes         |     |
:                ^                                 |       |         +-------------------------------+     |
:                |           responses             |       |             checkout previous versions        |
:                +---------------------------------+-------+                                               |
:                        json or raw HTML          |                                                       |
:                                                  +-------------------------------------------------------+

* The Example Application
  :PROPERTIES:
  :CUSTOM_ID: ex-app
  :END:
** Bugpile
   :PROPERTIES:
   :CUSTOM_ID: bugpile
   :END:
A bug tracker (bugpile) is used as an example application for iOrg
which provides an interactive web interface and bug reports stored in
Org-mode files. A 'lightweight--version' of a systematic software
engineering approach is used for the development of bugpile, that can
be used as a guide for developing web applications with iOrg.
** About Bugtrackers
   :PROPERTIES:
   :CUSTOM_ID: bugtrackers
   :END:
*** Why bugtrackers matter
    :PROPERTIES:
    :CUSTOM_ID: bugtr-matter
    :END:

The following quote from [[http://www.joelonsoftware.com/articles/fog0000000043.html][Joel Spolsky]] emphases the importance of
bugtrackers for good software development:

#+BEGIN_QUOTE
: Do you have a bug database?
: 
: I don't care what you say. If you are developing code, even on a team
: of one, without an organized database listing all known bugs in the
: code, you are going to ship low quality code. Lots of programmers
: think they can hold the bug list in their heads. Nonsense. I can't
: remember more than two or three bugs at a time, and the next morning,
: or in the rush of shipping, they are forgotten. You absolutely have to
: keep track of bugs formally.
: 
: Bug databases can be complicated or simple. A minimal useful bug
: database must include the following data for every bug:
: 
:   - complete steps to reproduce the bug
:   - expected behavior
:   - observed (buggy) behavior
:   - who it's assigned to
:   - whether it has been fixed or not
: 
: If the complexity of bug tracking software is the only thing stopping
: you from tracking your bugs, just make a simple 5 column table with
: these crucial fields and start using it.
#+END_QUOTE

*** Elements of a good bug report
    :PROPERTIES:
    :CUSTOM_ID: elem-bug-report
    :END:

Again citing [[http://www.joelonsoftware.com/articles/fog0000000029.html][Joel Spolsky]], here are the three fundamental elements of
a good bug report:

#+BEGIN_QUOTE
: It's pretty easy to remember the rule for a good bug report. Every
: good bug report needs exactly three things.
: 
:  1. Steps to reproduce,
:  2. What you expected to see, and
:  3. What you saw instead.
#+END_QUOTE

# ** The design of bugtrackers

** Popular free bugtrackers
   :PROPERTIES:
   :CUSTOM_ID: free-bug-tracker
   :END:
From the many free bugtrackers available, two have been of special
importance as inspiration and reference for the bugpile project:

- bugzilla :: a feature-rich, established and well documented
              [[http://www.bugzilla.org/][bugtracker]].
- flyspray :: an uncomplicated, web-based [[http://flyspray.org/][bug tracking system]], used
              by ArchLinux.

* Requirements Analysis
  :PROPERTIES:
  :CUSTOM_ID: req-analysis
  :END:
** Real World vs Software World
   :PROPERTIES:
   :CUSTOM_ID: real-world-vs-sw-world
   :END:
When applying an software-engineering like approach to (web)
application programming, it is important to be aware of the
distinction between the problem domain (in the real world) and the
solution domain (in the software world). The /requirements analysis/
is all about the real world and the users point of view. Even when
doing a one man project with only imaginary users that can't be
interviewed, the programmer should try to take on the role of a user
in this phase. The following phases (/specification/ and /design/)
transform the real-world model of the /analysis/ into a software model
in the solution space, which can then be implemented.

** Use Cases in textual form
   :PROPERTIES:
   :CUSTOM_ID: use-case-txt
   :END:

*** Register as user
    :PROPERTIES:
    :CUSTOM_ID: register-as-user-txt
    :END: 

|                    | <30>                           |
| *use case*         | register as user               |
| *actors*           | user                           |
| *precondition*     | --                             |
| *main flow*        | user selects the 'registration' option and enters 'username' (that might be a real name) and 'email' |
| *alternative flow* | --                             |
| *postcondition*    | user authentication data permanently stored in the system |

*** Edit user details
    :PROPERTIES:
    :CUSTOM_ID: edit-user-details-txt
    :END: 

|                    | <30>                           |
| *use case*         | edit user details              |
| *actors*           | user                           |
| *precondition*     | user is logged in              |
| *main flow*        | user selects 'edit user details' option, modifies some information, and stores the modified information |
| *alternative flow* | user selects the 'edit user details' option first, and then the 'delete user' option |
| *postcondition*    | user deleted or valid authentication data stored in the system |

*** Login
    :PROPERTIES:
    :CUSTOM_ID: login-txt
    :END: 

|                    | <30>                           |
| *use case*         | login                          |
| *actors*           | user                           |
| *precondition*     | user is registered             |
| *main flow*        | user selects the 'log in' option and enters his credentials |
| *alternative flow* | --                             |
| *postcondition*    | user is logged in              |

*** Logout
    :PROPERTIES:
    :CUSTOM_ID: logout-txt
    :END: 

|                    | <30>                           |
| *use case*         | logout                         |
| *actors*           | user                           |
| *precondition*     | user is logged in              |
| *main flow*        | user selects 'logout' option   |
| *alternative flow* | --                             |
| *postcondition*    | user is logged out             |

*** Search users
    :PROPERTIES:
    :CUSTOM_ID: search-users-txt
    :END: 

|                    | <30>                           |
| *use case*         | search users                   |
| *actors*           | admin                          |
| *precondition*     | admin is logged in             |
| *main flow*        | admin selects 'search users' option |
| *alternative flow* | --                             |
| *postcondition*    | admin sees registered users    |

*** Take action on selected users
    :PROPERTIES:
    :CUSTOM_ID: take-action-users-txt
    :END: 

/e.g.:/
- /add user(s) to assignees/
- /remove user(s) from assignees/
- /delete user(s)/
- /edit user details/

|                    | <30>                           |
| *use case*         | take action on selected users  |
| *actors*           | admin                          |
| *precondition*     | admin is logged in and at least one user registered |
| *main flow*        | admin selects users and the action to perform on them |
| *alternative flow* | --                             |
| *postcondition*    | action was applied to selected user(s) |

*** Create project
    :PROPERTIES:
    :CUSTOM_ID: create-project-txt
    :END: 

|                    | <30>                           |
| *use case*         | create project                 |
| *actors*           | admin                          |
| *precondition*     | admin is logged in             |
| *main flow*        | admin selects 'create project' option and submits project information |
| *alternative flow* | --                             |
| *postcondition*    | new project is stored in the system |

*** Edit project
    :PROPERTIES:
    :CUSTOM_ID: edit-project-txt
    :END:      

|                    | <30>                           |
| *use case*         | edit project                   |
| *actors*           | admin                          |
| *precondition*     | admin is logged in, project exists |
| *main flow*        | admin selects 'edit project' option, selects one project, and submits the modified project information |
| *alternative flow* | admin marks selected project as deleted |
| *postcondition*    | modified project info stored in the system OR project deleted |

*** Switch project
    :PROPERTIES:
    :CUSTOM_ID: switch-project-txt
    :END:   

|                    | <30>                           |
| *use case*         | switch project                 |
| *actors*           | user                           |
| *precondition*     | --                             |
| *main flow*        | user selects the 'switch project' option and selects a different project |
| *alternative flow* | --                             |
| *postcondition*    | a different project is the current project |

*** Open new task
    :PROPERTIES:
    :CUSTOM_ID: open-new-task-txt
    :END:      

|                    | <30>                           |
| *use case*         | open new task                  |
| *actors*           | user                           |
| *precondition*     | user is logged in              |
| *main flow*        | user selects 'open new task' option and submits task information. |
| *alternative flow* | --                             |
| *postcondition*    | task stored in system          |

*** Search tasklist
    :PROPERTIES:
    :CUSTOM_ID: search-task-list-txt
    :END: 

|                    | <30>                           |
| *use case*         | search tasklist                |
| *actors*           | user                           |
| *precondition*     | at least one task in system    |
| *main flow*        | user selects 'search tasklist' option and submits search criteria |
| *alternative flow* | --                             |
| *postcondition*    |                                |

*** Take action on selected tasks
    :PROPERTIES:
    :CUSTOM_ID: take-action-tasks-txt
    :END: 

/e.g.:/
- /add (remove) yourself (as user) to (from) notification list/
- /add (remove) reminder/
- /close task/
- /re-open closed task/
- /assign yourself (as assignee) to the task(s)/ 
- /edit task/
- /associate related tasks/
- /dissociate related tasks/
- /associate  tasks and assignees/
- /dissociate tasks and assignees/


|                    | <30>                           |
| *use case*         | take action on selected tasks  |
| *actors*           | user                           |
| *precondition*     | user has necessary permissions |
| *main flow*        | user select tasks and the action to perform on them |
| *alternative flow* | --                             |
| *postcondition*    | action performed on selected tasks |

*** Edit task
    :PROPERTIES:
    :CUSTOM_ID: edit-task-txt
    :END: 

|                    | <30>                           |
| *use case*         | edit task                      |
| *actors*           | admin or assignee              |
| *precondition*     | adminf or assignee logged in   |
| *main flow*        | admin or assignee searches the tasklist, selects a task, takes action 'edit' on the selected task, and finally submits the modified task info |
| *alternative flow* | --                             |
| *postcondition*    | modified task info stored in system |

# *** Associate tasks and assignees 
#     :PROPERTIES:
#     :CUSTOM_ID: assoc-task-assignee-txt
#     :END: 

# |                    | <30>                           |
# | *use case*         | associate tasks and assignees  |
# | *actors*           | admin                          |
# | *precondition*     | admin is logged in             |
# | *main flow*        | admin synchronously searches the task and user (assignee) lists, selects one or more tasks and one or more assignees, and takes action 'associate tasks and assignees' on them. |
# | *alternative flow* | --                             |
# | *postcondition*    | selected tasks are flagged as assigned to selected assignees |

# *** Dissociate tasks and assignees
#     :PROPERTIES:
#     :CUSTOM_ID: dissoc-tasks-assignee-txt
#     :END: 

# |                    | <30>                           |
# | *use case*         | dissociate assignees from tasks |
# | *actors*           | admin                          |
# | *precondition*     | selected tasks are flagged as assigned to selected assignees |
# | *main flow*        | admin synchronously searches the task and user (assignee) list, selects at least one task and one of its assigned assignees,  and takes action 'dissociate tasks and assignees' on them |
# | *alternative flow* | --                             |
# | *postcondition*    | selected tasks are not assigned to selected assignees anymore |

*** Add comment
    :PROPERTIES:
    :CUSTOM_ID: add-comment-txt
    :END: 

|                    | <30>                           |
| *use case*         | add comment                    |
| *actors*           | user                           |
| *precondition*     | user is logged in and views a task |
| *main flow*        | user submits a comment to the current task |
| *alternative flow* | --                             |
| *postcondition*    | comment stored in system       |

*** Edit comment
    :PROPERTIES:
    :CUSTOM_ID: edit-comment-txt
    :END: 

|                    | <30>                           |
| *use case*         | edit comment                   |
| *actors*           | user                           |
| *precondition*     | user is logged in and views a task with comments AND has necessary permissions |
| *main flow*        | user selects 'edit comment' option and submits edited text |
| *alternative flow* | user selects 'edit comment' option and deletes comment |
| *postcondition*    | edited comment stored in system |

*** Add attachment
    :PROPERTIES:
    :CUSTOM_ID: add-attachment-txt
    :END: 

|                    | <30>                           |
| *use case*         | add attachment                 |
| *actors*           | user                           |
| *precondition*     | user is logged in, views a task, and has the necessary permissions |
| *main flow*        | user selects 'add attachment' option and submits the selected file |
| *alternative flow* | --                             |
| *postcondition*    | selected file stored in the system and attached to task |

*** Delete attachment
    :PROPERTIES:
    :CUSTOM_ID: delete-attachment-txt
    :END: 

|                    | <30>                           |
| *use case*         | delete attachment              |
| *actors*           | user                           |
| *precondition*     | user is logged in, views a task with attachments, and has the necessary permissions |
| *main flow*        | user flags attachment as deleted and submits flag |
| *alternative flow* | --                             |
| *postcondition*    | attachment flagged as deleted in system |

*** Search event log 
    :PROPERTIES:
    :CUSTOM_ID: search-event-log-txt
    :END: 

|                    | <30>                           |
| *use case*         | search event log               |
| *actors*           | user                           |
| *precondition*     | --                             |
| *main flow*        | user selects 'search event log' option |
| *alternative flow* | --                             |
| *postcondition*    | --                             |

*** Two Use cases                                                  :noexport:
Here are some use cases demonstrating how the pieces all play
together, that should shed light on the couplings displayed above.

**** Change the state of a bug from TODO to DONE
First lets assume that we have a list of bugs stored in an Org-mode
document on the file system.  Each bug will be represented by a
headline with some meta-data stored in the properties, e.g.,

#+begin_src org
  ,* bugs
  ,** TODO foo doesn't work
  ,   :PROPERTIES:
  ,   :submitted-by: user-x
  ,   :assigned-to: user-y
  ,   :priority: HIGH
  ,   :ID:       515a1747-8ee1-42a7-8ca1-9a0c38844218
  ,   :END:
  ,I don't like it when =foo= doesn't work.  Here's my reproduction
  ,information...
  ,** TODO bar works too well
  ,   :PROPERTIES:
  ,   :submitted-by: user-y
  ,   :assigned-to: user-z
  ,   :priority: LOW
  ,   :ID:       cda87532-62f5-413d-a748-17bc909064f8
  ,   :END:
  ,Feature =bar= works too well and is making =foo= look bad, please stop
  ,showing off.
#+end_src

A remote user navigates to the bug listing page in her browser, the
browser requests the page from elnode, which requests the html export
of the page from Org, which reads the page from the file system,
exports to html which is then passed back to elnode which serves the
page.  Some JS is inserted into each headline adding buttons for
perform actions like changing the properties of a bug, editing its
contents etc...

The user has just completed the first bug "foo doesn't work", so she
hits the [close this bug] button.  The associated JS is run sending an
async post request to the server holding the id of the heading and the
data =state->DONE=.  Elnode parses this post request, and calls the
associated elisp function passing in the Org-id and the new state as
arguments.  This elisp function uses the Org-mode API to change the
state in the actual file on disk, it possibly also calls the
`vc-checkin' function (see vc.el) to commit the new version of the
file to the repository.

After this action is performed, Org-mode re-exports the changed
subtree to HTML.  This new HTML is returned by the function to elnode,
which sends it as a response to the async JS request.  On the browser
side the subtree holding this subtree is replaced with the new HTML
(in which the state is marked as DONE).

**** View a previous version of a wiki page
A user browses to a wiki page.  The corresponding page is rendered by
Org-mode to HTML and is wrapped in a wiki-specific template either by
the Org-mode publishing system or by elnode or by some combination of
the two (the framework).

Along those items included in the wrapping template are buttons for
reverting to a previous version.  The user selects this button sending
a request to elnode.  Elnode parses this request and calls the
corresponding vc function to list recent commits with commit messages.
These are then converted to HTML by elnode (possibly with the help of
Org-mode), and are displayed to the user.

The user selects a particular commit sending a request to the server.
This request includes the commit ID.  This ID is handed to a vc
function which checks out a version of the file at that ID, hands this
file to Org-mode which exports it to HTML, which is then handed to
elnode and served to the user.

# This would also require specifying the format of these
# Org-mode files (e.g., what properties do bugs have), and writing elisp
# functions which could be used outside of the framework e.g., for
# searching and sorting bug reports.

** Integrated UML Modelling of Use Cases and UI
   :PROPERTIES:
   :CUSTOM_ID: use-cases-uml
   :exports:  both
   :END:      

*** Requirements Oriented UML Activity Diagrams (ROA)
   :PROPERTIES:
   :CUSTOM_ID: req-oriented-act-uml
   :END:      

UML activity diagrams are well suited for modelling complex activities
with several alternative flows. Based on the [[id:use-case-txt][textual descriptions]] we
develop one diagram for each use case. While the meaning of the
diagrams should be self-explanatory (in fact, their main /razon
d'etre/ is easy communication with non-technical users), there are
some abbreviations and symbols that require explanation:

| <roa>     | requirements oriented activity |
| <<UA>>    | User Activity                  |
| <<UD>>    | User Decision                  |
| <<SA>>    | (complex) System Activity      |
| <<SD>>    | System Decision                |
| <<UC>>    | Use Case                       |
| *⋔*       | (pitchfork) sub-activity       |
| <<scene>> | basic elements of web UI       |


Each /activity/ has one startpoint and one or several endpoints. Each
/user activity/ is associated with a /scene/. Other /use cases/ that
are included in the use case modelled, as well as complex /system
activities/, are marked as subactivities with a pitchfork (⋔). Only
complex system activities are considered, not simple stuff like
storing form data. 

/note: use 'C-x 8 RET pitchfork' (type 'pit' then TAB for completion) to/
/enter the ⋔ character with Emacs (⋔ is used to mark subactivities)/

*** Register as user
    :PROPERTIES:
    :CUSTOM_ID: register-as-user-uml-roa
    :END: 

#+srcname register-as-user-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/register-as-user-uml-roa.png 
    title Register as User <roa>
    note right: <<precondition>> -- \n<<postcondition>> user credentials stored
    (*) -->  "<<UA>>\nSelect 'register' option"
      note right: <<scene>>\n<<button/link>>\nregister
      --> "<<UA>>\nSubmit entered credentials"
      note right: <<scene>>\n<<input attributes>>\n username, email\n<<button/link>>\nsubmit
      if "credentials valid?                                   " then
      --> [  true]  (*)
    else
      ---> [  false] "<<UA>>\nSubmit entered credentials"
    endif
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/register-as-user-uml-roa.png]]


*** Edit user details
    :PROPERTIES:
    :CUSTOM_ID: edit-user-details-uml-roa
    :END: 

#+srcname edit-user-details-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/edit-user-details-uml-roa.png 
  title Edit User Details <roa>
  note right: <<precondition>> user is logged in\n<<postcondition>> user deleted OR credentials stored
  (*) --> "<<UA>>\nSelect 'edit user details' option"
  note right: <<scene>>\n<<button/link>>\nedit user
  if "delete user?                   " then
    --> [true] "<<UA>>\nDelete user"
    note bottom: <<scene>>\n<<button/link>>\ndelete user
    --> (*)
  else
    --> [false] "<<UA>>\nSubmit modified credentials"
        note bottom: <<scene>>\n<<input attributes>>\n username, email\n<<button/link>>\nsubmit
    --> (*)
  endif
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/edit-user-details-uml-roa.png]]


*** Login
    :PROPERTIES:
    :CUSTOM_ID: login-uml-roa
    :END: 


#+srcname login-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/login-uml-roa.png 
  title Login <roa>
  note right: <<precondition>> user is registered
  (*) --> "<<UA>>\nSelect 'login' option"
  note right: <<scene>>\n<<button/link>>\nlogin
  if "                                              credentials valid?" then
    --> [  true] (*)
  else
    ---> [  false] "<<UA>>\nSelect 'login' option"
  endif
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/login-uml-roa.png]]



*** Logout
    :PROPERTIES:
    :CUSTOM_ID: logout-uml-roa
    :END: 


#+srcname logout-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/logout-uml-roa.png 
  title Logout <roa>
  note right: <<precondition>> user is logged in
  (*) --> "<<UA>>\nSelect 'logout' option"
  note right: <<scene>>\n<<button/link>>\nlogout
  --> (*)
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/logout-uml-roa.png]]


*** Search users
    :PROPERTIES:
    :CUSTOM_ID: search-users-uml-roa
    :END: 

#+srcname search-users--uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/search-users-uml-roa.png 
  title Search Users<roa>
  note right: <<precondition>> admin is logged in
  (*) --> "<<UA>>\nSelect 'search users' option"
  note right: <<scene>>\n<<button/link>>\nsearch users
  --> "<<UA>>\nDefine search criteria"
  note right: <<scene>>\n<<input attributes>>\nusername, email, task \n<<button/link>>\nsearch
  --> (*)
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/search-users-uml-roa.png]]



*** Take action on selected users
    :PROPERTIES:
    :CUSTOM_ID: take-action-select-users-uml-roa
    :END: 

#+srcname take-action-select-users-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/take-action-select-users-uml-roa.png 
  title Take action on selected user<roa>
  note right: <<precondition>> admin is logged in\n<<postcondition>>action on user performed
  (*) --> "<<UC>>\nSearch users ⋔" 
  --> "<<UA>>\nTake action on selected users"
  note right: <<scene>>\n<<button/link>>>>\nsubmit
  --> (*)
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/take-action-select-users-uml-roa.png]]


*** Create project
    :PROPERTIES:
    :CUSTOM_ID: create-project-uml-roa
    :END: 

#+srcname create-project-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/create-project-uml-roa.png 
  title Create project <roa>
  note right: <<precondition>> admin is logged in\n<<postcondition>>new project is stored in the system
  (*) --> "<<UA>>\nSelect 'create project' option"
  note right: <<scene>>\n<<button/link>>\ncreate project
  --> "<<UA>>\nSubmit project information"
  note right: <<scene>>\n<<input attributes>>\nname\n<<button/link>>\nsubmit
  --> (*)
#+end_src


*** Edit project
    :PROPERTIES:
    :CUSTOM_ID: edit-project-uml-roa
    :END:      

#+srcname edit-project-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/edit-project-uml-roa.png 
  title Edit project <roa>
  note right: <<precondition>>admin is logged in and project exists\n<<postcondition>>modified project info stored in the system or project deleted
  (*) --> "<<UA>>\nSelect 'edit project' option"
  note right: <<scene>>\n<<button/link>>\nedit project
  --> "<<UA>>\nSubmit modified project information"
  note right: <<scene>>\n<<input attributes>>\nname, deleted \n<<button/link>>\nsubmit
  --> (*)
#+end_src

*** Switch project
    :PROPERTIES:
    :CUSTOM_ID: switch-project-uml-roa
    :END: 

#+srcname switch-project-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/switch-project-uml-roa.png 
  title Switch project <roa>
  note right: <<precondition>>--\n<<postcondition>>a different project is the current project
  (*) --> "<<UA>>\nSelect 'switch project' option"
  note right: <<scene>>\n<<button/link>>\nswitch project
  --> "<<UA>>\nSubmit selected project"
  note right: <<scene>>\n<<select option>>\nproject name\n<<button/link>>\nsubmit
  --> (*)
#+end_src

*** Open new task
    :PROPERTIES:
    :CUSTOM_ID: open-new-task-uml-roa
    :END:      

#+srcname open-new-task-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/open-new-task-uml-roa.png 
  title Open New Task <roa>
  note right: <<precondition>> user is logged in\n<<postcondition>>task stored in system
  (*) --> "<<UA>>\nSelect 'open new task' option"
  note right: <<scene>>\n<<button/link>>\nedit new task
  --> "<<UA>>\nSubmit task information"
  note right: <<scene>>\n<<input attributes>>\nproject, type, severity, description \n<<button/link>>\nsubmit
  --> (*)
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/open-new-task-uml-roa.png]]



*** Search tasklist
    :PROPERTIES:
    :CUSTOM_ID: search-task-list-uml-roa
    :END: 

#+srcname search-tasklist--uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/search-tasklist-uml-roa.png 
  title Search tasklist <roa>
  note right: <<precondition>>at least one task in system<<postcondition>>--
  (*) --> "<<UA>>\nSelect 'search tasklist' option"
  note right: <<scene>>\n<<button/link>>\nsearch tasklist
  --> "<<UA>>\nDefine search criteria"
  note right: <<scene>>\n<<input attributes>>\nname, id, keyword \n<<button/link>>\nsearch
  --> (*)
#+end_src

*** Take action on selected tasks
    :PROPERTIES:
    :CUSTOM_ID: take-action-tasks-uml-roa
    :END: 

#+srcname take-action-select-tasks-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/take-action-select-tasks-uml-roa.png 
  title Take action on selected tasks<roa>
  note right: <<precondition>>user is logged in and has necessary permissions\n<<postcondition>>action performed on selected tasks
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  --> "<<UA>>\nTake action on selected tasks"
  note right: <<scene>>\n<<button/link>>>>\nsubmit
  --> (*)
#+end_src


*** Edit task
    :PROPERTIES:
    :CUSTOM_ID: edit-task-uml-roa
    :END: 

#+srcname edit-task-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/edit-task-uml-roa.png 
  title Edit task<roa>
  note right: <<precondition>> admin or assignee logged in\n<<postcondition>> modified task info stored in system
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  --> "<<UA>>\nEdit task"
  note right: <<scene>>\n<<button/link>>>>\nsubmit
  --> (*)
#+end_src


# *** Associate tasks and assignees 
#     :PROPERTIES:
#     :CUSTOM_ID: assoc-task-assignee-uml-roa
#     :END: 

# # |                    | <30>                           |
# # | *use case*         | associate tasks and assignees  |
# # | *actors*           | admin                          |
# # | *precondition*     | admin is logged in             |
# # | *main flow*        | admin synchronously searches the task and user (assignee) lists, selects one or more tasks and one or more assignees, and takes action 'associate tasks and assignees' on them. |
# # | *alternative flow* | --                             |
# # | *postcondition*    | selected tasks are flagged as assigned to selected assignees |

# *** Dissociate tasks and assignees
#     :PROPERTIES:
#     :CUSTOM_ID: dissoc-tasks-assignee-uml-roa
#     :END: 

# # |                    | <30>                           |
# # | *use case*         | dissociate assignees from tasks |
# # | *actors*           | admin                          |
# # | *precondition*     | selected tasks are flagged as assigned to selected assignees |
# # | *main flow*        | admin synchronously searches the task and user (assignee) list, selects at least one task and one of its assigned assignees,  and takes action 'dissociate tasks and assignees' on them |
# # | *alternative flow* | --                             |
# # | *postcondition*    | selected tasks are not assigned to selected assignees anymore |


*** Add comment
    :PROPERTIES:
    :CUSTOM_ID: add-comment-uml-roa
    :END: 

#+srcname add-comment-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/add-comment-uml-roa.png 
  title Add comment <roa>
  note right: <<precondition>> user is logged in\n<<postcondition>> comment stored in system
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  --> "<<UA>>\nSubmit comment"
  note right: <<scene>>\n<<textarea>>\ncomment\n<<button/link>>>>\nsubmit
  --> (*)
#+end_src


*** Edit comment
    :PROPERTIES:
    :CUSTOM_ID: edit-comment-uml-roa
    :END: 

#+srcname edit-comment-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/edit-comment-uml-roa.png 
  title Edit comment <roa>
  note right: <<precondition>> user is logged in\n<<postcondition>> edited comment stored in system or comment deleted
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  if "delete comment?                   " then
    --> [true] "<<UA>>\nDelete comment"
    note bottom: <<scene>>\n<<button/link>>\ndelete comment
    --> (*)
  else
    --> [false] "<<UA>>\nSubmit modified comment"
        note bottom: <<scene>>\n<<text area>>\ncomment\n<<button/link>>\nsubmit
    --> (*)
  endif
#+end_src

*** Add attachment
    :PROPERTIES:
    :CUSTOM_ID: add-attachment-uml-roa
    :END: 

#+srcname add-attachment-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/add-attachment-uml-roa.png 
  title Add attachment <roa>
  note right: <<precondition>> user is logged in\n<<postcondition>> selected file stored in the system and attached to task
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  --> "<<UA>>\nAdd attachment"
  note right: <<scene>>\n<<select option>>\nfile\n<<button/link>>>>\nadd file
  --> (*)
#+end_src


*** Delete attachment
    :PROPERTIES:
    :CUSTOM_ID: delete-attachment-uml-roa
    :END: 

#+srcname delete-attachment-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/delete-attachment-uml-roa.png 
  title Delete attachment <roa>
  note right: <<precondition>> user is logged in\n<<postcondition>> attachment flagged as deleted in system
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  --> "<<UA>>\nDelete attachment"
  note right: <<scene>>\n<<button/link>>>>\ndelete
  --> (*)
#+end_src


*** Search event log 
    :PROPERTIES:
    :CUSTOM_ID: search-event-log-uml-roa
    :END: 

#+srcname search-event-log-uml-roa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/search-event-log-uml-roa.png 
  title Search event log<roa>
  note right: <<precondition>> -- <<precondition>> --
  (*) --> "<<UA>>\nSelect 'search event log' option"
  note right: <<scene>>\n<<button/link>>\nsearch events
  --> "<<UA>>\nDefine search criteria"
  note right: <<scene>>\n<<input attributes>>\nname, date, type \n<<button/link>>\nsearch
  --> (*)
#+end_src


** Use Case Models
   :PROPERTIES:
   :CUSTOM_ID: use-case-models
   :exports:  both
   :END:

*** User management
    :PROPERTIES:
    :CUSTOM_ID: user-management-uc-model
    :END: 

#+srcname user-management-uml-uc
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/user-management-uml-uc.png
  title Use Cases for\n<b>User Management</b>

  :User: <<Human>>
  :Admin: <<Human>>

  User <|-down- Admin

  usecase (Register as user) as (Reg)
  usecase (Edit user details) as (Ed)
  usecase (Login) as (In)
  usecase (Logout) as (Out)
  usecase (Search users) as (Search)
  usecase (Take action on selected user) as (Act)

  (Act) .> (Search) : <<include>>

  Admin --> (Search)
  Admin --> (Act)
  (Reg) <--  User
  (Ed) <-- User  
  (In) <- User
  User -> (Out) 
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/user-management-uml-uc.png]]

*** Task management
    :PROPERTIES:
    :CUSTOM_ID: task-management-uc-model
    :END: 

#+srcname task-management-uml-uc
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/task-management-uml-uc.png
  title Use Cases for\n<b>Task  Management</b>

  :User: <<Human>>
  :Assignee: <<Human>>
  :Admin:  <<Human>>

  User <|-- Assignee
  Assignee <|-- Admin

  usecase (Open new task) as (OpenTask)
  usecase (Edit task) as (EdTask)
  usecase (Add comment) as (AddCom)
  usecase (Edit comment) as (EdCom)
  usecase (Add attachment) as (AddAtt)
  usecase (Delete attachment) as (DelAtt)
  usecase (Search eventlog) as (SearchLog)
  usecase (Search tasklist) as (SearchTask)
  usecase (Take action on selected tasks) as (ActOnTask)

  (AddCom) ....> (SearchTask) : <<include>>
  (EdCom) ....> (SearchTask) : <<include>>
  (SearchTask) <..... (AddAtt) : <<include>>
  (SearchTask) <..... (DelAtt): <<include>>
  (ActOnTask) .....> (SearchTask) : <<include>>
  (EdTask) ....> (SearchTask) : <<include>>

  User -> (SearchTask)
  (ActOnTask) <- Assignee  
  (OpenTask) <- User
  Assignee -> (EdTask)
  (AddCom) <-- User
  (EdCom) <-- User
  (AddAtt) <-- User
  (DelAtt) <--  User
  User --> (SearchLog)
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/task-management-uml-uc.png]]


/note: when plantuml has difficulties to calculate a complex diagram/
/or produces less than satisfactory output, try adding more slashes/
/or points to the vertices (e.g. .....> or <----) and watch what/
/happens./


*** Project management
    :PROPERTIES:
    :CUSTOM_ID: project-management-uc-model
    :END: 

#+srcname project-management-uml-uc
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/project-management-uml-uc.png
  title Use Cases for\n<b>Project  Management</b>

  :User: <<Human>>
  :Admin:  <<Human>>

  User <|-- Admin

  usecase (Create project) as (Crea)
  usecase (Edit project) as (Ed)
  usecase (Switch project) as (Swi)

  Admin --> (Crea)
  Admin --> (Ed)
  User -> (Swi) 
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/project-management-uml-uc.png]]

** Domain Class Model
   :PROPERTIES:
   :CUSTOM_ID: domain-class-model
   :exports: both
   :END:
*** Classes vs Attributes
     :PROPERTIES:
     :CUSTOM_ID: class-vs-attr
     :END:
When designing a class hierarchy, it is often necessary to decide if
the differences between two real-world classes should be modeled by
inserting a discriminating attribute into one software class (e.g.
attribute =color= in class =car=, with values white, green and black)
or by specialing a general superclass into several subclasses (e.g.
let subclasses =van=, =four-wheel= and =cabriolet=, each with a new
subset of attributes, inherit from superclass =car=).

While there are more sophisticated guidelines how to tackle this
decision in the literature, we will restrict ourselves to common
sense: "Does it make sense to introduce more (sub-) classes to
differentiate between variations of an real-world object?". In many
cases, the introduction of a new discriminating attribute will
suffice. 

*** Bugpile Domain Class Model
    :PROPERTIES:
    :CUSTOM_ID: bugpile-dom-class-model
    :END:

#+srcname domain-class-uml
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/domain-class-uml.png 
  title Domain Class Model
  User : name\nemail\nrole
  Role : role_ALL
  Permissions : <<role-permissions>>
  Task : name\ntype\nid\ndate\nauthor\nproject\nstate
  
  User "             0..*" -down- "1..*           " Role
  Role "1..*" -left- "1..*" Permission
  User "             0..*" -down- "1..*           " Task
  
  
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/domain-class-uml.png]]

* Software Specification
  :PROPERTIES:
  :CUSTOM_ID: softw-spec
  :END:
** Transforming Requirements into Specifications
   :PROPERTIES:
   :CUSTOM_ID: trans-req-into-spec
   :exports:  both
   :END:
*** Software Oriented UML Activity Diagrams (SOA)
   :PROPERTIES:
   :CUSTOM_ID: req-oriented-act-uml
   :END:      

We used UML activity diagrams in the requirements analysis to model
the real world system from the user's point of view. Now, the
[[id:req-oriented-act-uml][requirements oriented activitiy diagrams (roa)]] have to be transformed
into a software specification that forms the basis for the design of a
software system. We call the tranformed diagrams /software oriented/
/activity diagrams/. The transformation rule is easy and the whole
transformation process might well be implemented as a non-interactive
function:

#+begin_quote
*Transformation Rule*

Each edge from a vertex with a user action has its endpoint in a
vertex with a system action. 
#+end_quote

This reflects the typical behaviour of interactive systems, where
every user action is followed by a system reaction. The reason to not
include these /system (re-)action vertices/ in the activity diagrams
from the start is to keep the diagrams simple and focussed on the
user's point of view. After all, the requirement analysis is about
communicating with non-technical end users (or, in one-man-projects,
about the programmer taking on the role of the non-technical end
user).

For convenience, we repeat the explanation of abbreviations and
symbols used in the /activity diagrams/ here, but there is really only
one new abbreviation involved: /<soa>/ for /software oriented
activity/: 

| <soa>     | software oriented activity |
| <<UA>>    | User Activity              |
| <<UD>>    | User Decision              |
| <<SA>>    | (complex) System Activity  |
| <<SD>>    | System Decision            |
| <<UC>>    | Use Case                   |
| *⋔*       | (pitchfork) sub-activity   |
| <<scene>> | basic elements of web UI   |


/note: we make no attempt to conform to/ [[http://www.omg.org/spec/][formal uml specifications]]
/since we want to keep things simple and our text-based drawing tool/
[[http://plantuml.sourceforge.net/][PlantUML]] /does have its limitations when it comes to draw exactly the/
/diagram you want. On the other hand, UML source code as plain text/
/turns out to be a huge advantage when attempting to programmatically/
/transform UML diagrams into source code skeletons./

*** Register as user
    :PROPERTIES:
    :CUSTOM_ID: register-as-user-uml-soa
    :END: 

#+srcname register-as-user-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/register-as-user-uml-soa.png 
    title Register as User <soa>
    note right: <<precondition>> -- \n<<postcondition>> user credentials stored
    (*) -->  "<<UA>>\nSelect 'register' option"
      note right: <<scene>>\n<<button/link>>\nregister
      --> "<<SA>>\nShow register formular"
      --> "<<UA>>\nSubmit entered credentials"
      note right: <<scene>>\n<<input attributes>>\n username, email\n<<button/link>>\nsubmit
      --> "<<SA>>\nValidate entered credentials"
      if "credentials valid?                                   " then
      --> [  true] "<<SA>>\nStore entered credentials"
      -->  (*)
    else
      ---> [  false] "<<UA>>\nSubmit entered credentials"
    endif
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/register-as-user-uml-soa.png]]

*** Edit user details
    :PROPERTIES:
    :CUSTOM_ID: edit-user-details-uml-soa
    :END: 

#+srcname edit-user-details-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/edit-user-details-uml-soa.png 
  title Edit User Details <soa>
  note right: <<precondition>> user is logged in\n<<postcondition>> user deleted OR credentials stored
  (*) --> "<<UA>>\nSelect 'edit user details' option"
  note right: <<scene>>\n<<button/link>>\nedit user
  --> "<<SA>>\nShow 'edit user details' form"
  if "delete user?                   " then
    --> [true] "<<UA>>\nDelete user"
    note bottom: <<scene>>\n<<button/link>>\ndelete user
    --> "<<SA>>\nFlag user as deleted"
    --> (*)
  else
    --> [false] "<<UA>>\nSubmit modified credentials"
        note bottom: <<scene>>\n<<input attributes>>\n username, email\n<<button/link>>\nsubmit
      --> "<<SA>>\nValidate modified credentials"
      if "credentials valid?                                   " then
      --> [  true] "<<SA>>\nStore modified credentials"
      -->  (*)
     else
      ---> [  false] "<<UA>>\nSubmit modified credentials"
     endif
    --> (*)
  endif
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/edit-user-details-uml-soa.png]]

*** Login
    :PROPERTIES:
    :CUSTOM_ID: login-uml-soa
    :END: 


#+srcname login-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/login-uml-soa.png 
  title Login <soa>
  note right: <<precondition>> user is registered
  (*) --> "<<UA>>\nSelect 'login' option"
  note right: <<scene>>\n<<button/link>>\nlogin
  --> "<<SA>>\nValidate credentials" 
     if "                                                 credentials valid?" then
       --> [  true] "<<SA>>\nLogin user" 
       --> (*)
     else
       ---> [  false] "<<UA>>\nSelect 'login' option"
     endif
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/login-uml-soa.png]]

*** Logout
    :PROPERTIES:
    :CUSTOM_ID: logout-uml-soa
    :END: 


#+srcname logout-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/logout-uml-soa.png 
  title Logout <soa>
  note right: <<precondition>> user is logged in
  (*) --> "<<UA>>\nSelect 'logout' option"
  note right: <<scene>>\n<<button/link>>\nlogout
  --> "<<SA>>\nLogout user"
  --> (*)
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/logout-uml-soa.png]]


*** Open new task
    :PROPERTIES:
    :CUSTOM_ID: open-new-task-uml-soa
    :END:      

#+srcname open-new-task-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/open-new-task-uml-soa.png 
  title Open New Task <soa>
  note right: <<precondition>> user is logged in\n<<postcondition>>task stored in system
  (*) --> "<<UA>>\nSelect 'open new task' option"
  note right: <<scene>>\n<<button/link>>\nopen new task
  --> "<<SA>>\nShow 'open new task' page"
  --> "<<UA>>\nSubmit task information"
  note right: <<scene>>\n<<input attributes>>\nproject, type, severity, description \n<<button/link>>\nsubmit
  if "task information valid?                                   " then
      --> [  true] "<<SA>>\nStore new task"
      -->  (*)
 else
      ---> [  false] "<<UA>>\nSubmit task information"
 endif
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/open-new-task-uml-soa.png]]



*** Search users
    :PROPERTIES:
    :CUSTOM_ID: search-users-uml-soa
    :END: 

#+srcname search-users--uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/search-users-uml-soa.png 
  title Search Users<soa>
  note right: <<precondition>> admin is logged in
  (*) --> "<<UA>>\nSelect 'search users' option"
  note right: <<scene>>\n<<button/link>>\nsearch users
  --> "<<SA>>\nShow user search form"
  --> "<<UA>>\nDefine user search criteria"
  note right: <<scene>>\n<<input attributes>>\nusername, email, task \n<<button/link>>\nsearch
  --> "<<SA>>\nSearch users ⋔"
  --> (*)
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/search-users-uml-soa.png]]



*** Take action on selected users
    :PROPERTIES:
    :CUSTOM_ID: take-action-select-users-uml-soa
    :END: 

#+srcname take-action-select-users-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/take-action-select-users-uml-soa.png 
  title Take action on selected users<soa>
  note right: <<precondition>> admin is logged in
  (*) --> "<<UC>>\nSearch users ⋔" 
  --> "<<UA>>\nTake action on selected users"
  note right: <<scene>>\n<<button/link>>>>\nsubmit
  --> "<<SA>>\nPerform action on selected users"
  --> (*)
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/take-action-select-users-uml-soa.png]]


*** Create project
    :PROPERTIES:
    :CUSTOM_ID: create-project-uml-soa
    :END: 

#+srcname create-project-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/create-project-uml-soa.png 
  title Create project <soa>
  note right: <<precondition>> admin is logged in\n<<postcondition>>new project is stored in the system
  (*) --> "<<UA>>\nSelect 'create project' option"
  note right: <<scene>>\n<<button/link>>\ncreate project
  --> "<<SA>>\nShow 'create project' form"
  --> "<<UA>>\nSubmit project information"
  note right: <<scene>>\n<<input attributes>>\nname\n<<button/link>>\nsubmit
  if "project information valid?                                   " then
      --> [  true] "<<SA>>\nStore new project"
      -->  (*)
 else
      ---> [  false] "<<UA>>\nSubmit project information"
 endif
#+end_src


*** Edit project
    :PROPERTIES:
    :CUSTOM_ID: edit-project-uml-soa
    :END:      

#+srcname edit-project-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/edit-project-uml-soa.png 
  title Edit project <soa>
  note right: <<precondition>>admin is logged in and project exists\n<<postcondition>>modified project info stored in the system or project deleted
  (*) --> "<<UA>>\nSelect 'edit project' option"
  note right: <<scene>>\n<<button/link>>\nedit project
  --> "<<SA>>\nShow 'edit project' form"
  --> "<<UA>>\nSubmit modified project information"
  note right: <<scene>>\n<<input attributes>>\nname, deleted \n<<button/link>>\nsubmit
  if "project information valid?                                   " then
      --> [  true] "<<SA>>\nStore modified project"
      -->  (*)
 else
      ---> [  false] "<<UA>>\nSubmit modified project information"
 endif
#+end_src

*** Switch project
    :PROPERTIES:
    :CUSTOM_ID: switch-project-uml-soa
    :END: 

#+srcname switch-project-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/switch-project-uml-soa.png 
  title Switch project <soa>
  note right: <<precondition>>--\n<<postcondition>>a different project is the current project
  (*) --> "<<UA>>\nSelect 'switch project' option"
  note right: <<scene>>\n<<button/link>>\nswitch project
  --> "<<SA>>\nShow 'switch project' form"
  --> "<<UA>>\nSubmit selected project"
  note right: <<scene>>\n<<select option>>\nproject name\n<<button/link>>\nsubmit
  --> "<<SA>>\nSwitch to selected project"
  --> (*)
#+end_src

*** Search tasklist
    :PROPERTIES:
    :CUSTOM_ID: search-task-list-uml-soa
    :END: 

#+srcname search-tasklist-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/search-tasklist-uml-soa.png 
  title Search tasklist <soa>
  note right: <<precondition>>at least one task in system<<postcondition>>--
  (*) --> "<<UA>>\nSelect 'search tasklist' option"
  note right: <<scene>>\n<<button/link>>\nsearch tasklist
  --> "<<SA>>\nShow task search form"
  --> "<<UA>>\nDefine search criteria"
  note right: <<scene>>\n<<input attributes>>\nname, id, keyword \n<<button/link>>\nsearch
  --> "<<SA>>\nSearch tasks ⋔"
  --> (*)
#+end_src

*** Take action on selected tasks
    :PROPERTIES:
    :CUSTOM_ID: take-action-tasks-uml-soa
    :END: 

#+srcname take-action-select-tasks-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/take-action-select-tasks-uml-soa.png 
  title Take action on selected tasks <soa>
  note right: <<precondition>>user is logged in and has necessary permissions\n<<postcondition>>action performed on selected tasks
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  --> "<<UA>>\nTake action on selected tasks"
  note right: <<scene>>\n<<button/link>>>>\nsubmit
  --> "<<SA>>\nPerform action on selected tasks"
  --> (*)
#+end_src

*** Edit task
    :PROPERTIES:
    :CUSTOM_ID: edit-task-uml-soa
    :END: 

#+srcname edit-task-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/edit-task-uml-soa.png 
  title Edit task <soa>
  note right: <<precondition>> admin or assignee logged in\n<<postcondition>> modified task info stored in system
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  --> "<<UA>>\nEdit task"
  note right: <<scene>>\n<<button/link>>>>\nsubmit
  --> (*)
#+end_src


# *** Associate tasks and assignees 
#     :PROPERTIES:
#     :CUSTOM_ID: assoc-task-assignee-uml-roa
#     :END: 

# # |                    | <30>                           |
# # | *use case*         | associate tasks and assignees  |
# # | *actors*           | admin                          |
# # | *precondition*     | admin is logged in             |
# # | *main flow*        | admin synchronously searches the task and user (assignee) lists, selects one or more tasks and one or more assignees, and takes action 'associate tasks and assignees' on them. |
# # | *alternative flow* | --                             |
# # | *postcondition*    | selected tasks are flagged as assigned to selected assignees |

# *** Dissociate tasks and assignees
#     :PROPERTIES:
#     :CUSTOM_ID: dissoc-tasks-assignee-uml-roa
#     :END: 

# # |                    | <30>                           |
# # | *use case*         | dissociate assignees from tasks |
# # | *actors*           | admin                          |
# # | *precondition*     | selected tasks are flagged as assigned to selected assignees |
# # | *main flow*        | admin synchronously searches the task and user (assignee) list, selects at least one task and one of its assigned assignees,  and takes action 'dissociate tasks and assignees' on them |
# # | *alternative flow* | --                             |
# # | *postcondition*    | selected tasks are not assigned to selected assignees anymore |


*** Add comment
    :PROPERTIES:
    :CUSTOM_ID: add-comment-uml-soa
    :END: 

#+srcname add-comment-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/add-comment-uml-soa.png 
  title Add comment <soa>
  note right: <<precondition>> user is logged in\n<<postcondition>> comment stored in system
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  --> "<<UA>>\nSubmit comment"
  note right: <<scene>>\n<<textarea>>\ncomment\n<<button/link>>>>\nsubmit
  if "comment valid?                                   " then
      --> [  true] "<<SA>>\nStore comment"
      -->  (*)
 else
      ---> [  false] "<<UA>>\nSubmit comment"
 endif
#+end_src


*** Edit comment
    :PROPERTIES:
    :CUSTOM_ID: edit-comment-uml-soa
    :END: 

#+srcname edit-comment-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/edit-comment-uml-soa.png 
  title Edit comment <soa>
  note right: <<precondition>> user is logged in\n<<postcondition>> edited comment stored in system or comment deleted
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  if "                                   delete comment?" then
    --> [true] "<<UA>>\nDelete comment"
    note bottom: <<scene>>\n<<button/link>>\ndelete comment
  --> "<<SA>>\nFlag comment as deleted"
    --> (*)
  else
    --> [false] "<<UA>>\nSubmit modified comment"
        note bottom: <<scene>>\n<<text area>>\ncomment\n<<button/link>>\nsubmit
         if "                                            Modified comment valid?" then
             --> [  true] "<<SA>>\nStore modified comment"
              -->  (*)
         else
             ---> [  false] "<<UA>>\nSubmit modified comment"
         endif
    endif
#+end_src

*** Add attachment
    :PROPERTIES:
    :CUSTOM_ID: add-attachment-uml-soa
    :END: 

#+srcname add-attachment-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/add-attachment-uml-soa.png 
  title Add attachment <soa>
  note right: <<precondition>> user is logged in\n<<postcondition>> selected file stored in the system and attached to task
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  --> "<<UA>>\nAdd attachment"
  note right: <<scene>>\n<<select option>>\nfile\n<<button/link>>>>\nadd file
  if "attachment valid?                                   " then
      --> [  true] "<<SA>>\nStore attachment"
      -->  (*)
 else
      ---> [  false] "<<UA>>\nAdd attachment"
 endif
#+end_src


*** Delete attachment
    :PROPERTIES:
    :CUSTOM_ID: delete-attachment-uml-soa
    :END: 

#+srcname delete-attachment-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/delete-attachment-uml-soa.png 
  title Delete attachment <soa>
  note right: <<precondition>> user is logged in\n<<postcondition>> attachment flagged as deleted in system
  (*) --> "<<UC>>\nSearch tasks ⋔" 
  --> "<<UA>>\nDelete attachment"
  note right: <<scene>>\n<<button/link>>>>\ndelete
  --> "<<SA>>\nDelete attachment"
  --> (*)
#+end_src


*** Search event log 
    :PROPERTIES:
    :CUSTOM_ID: search-event-log-uml-soa
    :END: 

#+srcname search-event-log-uml-soa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/search-event-log-uml-soa.png 
  title Search event log <soa>
  note right: <<precondition>> -- <<precondition>> --
  (*) --> "<<UA>>\nSelect 'search event log' option"
  note right: <<scene>>\n<<button/link>>\nsearch events
  --> "<<SA>>\nShow 'search event log' form"
  --> "<<UA>>\nDefine search criteria"
  note right: <<scene>>\n<<input attributes>>\nname, date, type \n<<button/link>>\nsearch
  --> "<<SA>>\nShow queried log entries"
  --> (*)
#+end_src


** Complex System Activities
   :PROPERTIES:
   :CUSTOM_ID: syst-activities
   :END:
*** Modeling complex system activities
    :PROPERTIES:
    :CUSTOM_ID: model-compl-syst-act
    :END:

System activities that are sufficiently complex are marked as
/subactivities/ with the =pitchfork= symbol ⋔ in the software oriented
activitiy diagrams (=soa=). They are modeled separately in a stepwise
refinement process by decomposing them into small atomar system
activities and (maybe) other complex system activities, that are then
decomposed into smaller activities themselves in another step until
only simple atomar activities are left.

The following symbols are used when modeling complex system activities:

| <csa>  | Complex System Activity   |
| <<SA>> | (complex) System Activity |
| <<SD>> | System Decision           |
| *⋔*    | (pitchfork) sub-activity  |


*** Search Tasks
    :PROPERTIES:
    :CUSTOM_ID: search-tasks-syst-act-spec
    :END:

Search tasks and return a result set that fits a user query is the
central complex system activity in a bugtracker. It is (indirectly)
included as subactivity in many use cases.

#+srcname search-tasks-uml-csa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/search-tasks-uml-csa.png 
  title Search tasks <csa>
  note right: <<precondition>>--<<postcondition>>--
  (*) --> "<<SA>>\nSystem activity 1"
  --> "<<SA>>\nSystem activity 2"
  --> "<<SA>>\nSystem activity 3"
  --> "<<SA>>\nComplex system activity ⋔"
  --> (*)
#+end_src

*** Search Users
    :PROPERTIES:
    :CUSTOM_ID: search-users-syst-act-spec
    :END:

In bugpile, querying users is a less important and less complex
activity (compared to querying tasks), only performed by /admins/.

#+srcname search-users-uml-csa
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/search-users-uml-csa.png 
  title Search users <csa>
  note right: <<precondition>>--<<postcondition>>--
  (*) --> "<<SA>>\nSystem activity 1"
  --> "<<SA>>\nSystem activity 2"
  --> "<<SA>>\nSystem activity 3"
  --> (*)
#+end_src


* Software Architecture
  :PROPERTIES:
  :CUSTOM_ID: softw-arch
  :END:
** Modified 5-Layer Architecture
   :PROPERTIES:
   :CUSTOM_ID: 5-layer-arch
   :END:

The iOrg web-framework is based on a modified 5-layer architecture
(modified, because the web-layer is further divided into /view/ and
/controller/):

|-------------------------|
| iOrg Architecture       |
|-------------------------|
| Client                  |
|-------------------------|
| Web (View & Controller) |
|-------------------------|
| Logic (Model)           |
|-------------------------|
| Objects (Model)         |
|-------------------------|
| Persistence             |
|-------------------------|

The standard /client/ for an iOrg web-application is, not
surprisingly, a web-browser, but typically power users that access the
application directly via Emacs are considered too. Since iOrg is
entirely based on text files, a dVCS in combination with the servers
file system is used for /persistence/, version control and simple
database functionality. 

Programming an iOrg application therefore consists in designing and
implementing the three middle layers /objects/, /logic/ and /web/.
Combining objects and logic into the application /model/ and dividing
the web-layer into a /view/ and a /controller/ component results in
the well known MVC (Model-View-Controller) pattern for web
applications. 

The described architecture is platform independent. We adapt it to the
file based iOrg system by defining a standard directory structure for
iOrg projects with predefined directories that contain all the files
that belong to a certain layer of the architecture. The directories
are drawn as packages in the following graphical depiction, and
actually serve the same purpose as packages in other programming
environments. 

#+srcname refined-arch-iorg
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/refined-arch-iorg.png 
    title iOrg Architecture
 
   package Project_DIR {
    package View_DIR {
      package UseCase1_DIR {
          package Scene1_UC1_FILE {}
          package Scene2_UC1_FILE {}
    }
      package UseCase2_DIR {
          package Scene1_UC2_FILE {} 
          package Scene2_UC2_FILE {}
      }
  
      package UseCaseIndependentComponents_DIR {
          package Components_FILE {} 
    }
  }
  
    package Controller_DIR {
          package Controller_UC1_FILE {}
          package Controller_UC2_FILE {}
          package UseCaseIndepCompController_FILE {}
    }
  
    package Logic_DIR {
          package Logic_UC1_FILE {}
          package Logic_UC2_FILE {}
          package UseCaseIndepCompLogic_FILE {}
    }
  
    package Objects_DIR {
          package Object1_FILE {}
          package Object2_FILE {}
          package Classes_DIR {
              package Class1_FILE {}
              package Class2_FILE {}
          }
    }
}  

  UseCase1_DIR +-down- UseCase2_DIR
  UseCase2_DIR +-down- UseCaseIndependentComponents_DIR
  View_DIR +-down--- Controller_DIR
  Controller_DIR +-left----------- Logic_DIR
  Logic_DIR  +-left------ Objects_DIR
  Logic_UC1_FILE +-down- Logic_UC2_FILE
  Logic_UC2_FILE +-down- UseCaseIndepCompLogic_FILE
  Scene1_UC1_FILE +-down- Scene2_UC1_FILE
  Scene1_UC2_FILE +-down- Scene2_UC2_FILE
  Controller_UC1_FILE +-down- Controller_UC2_FILE
  Controller_UC2_FILE +-down- UseCaseIndepCompController_FILE
  Object1_FILE +-down- Object2_FILE
  Object2_FILE +-down- Classes_DIR
  Class1_FILE +-down- Class2_FILE
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/refined-arch-iorg.png]]


An iOrg project therefore contains a /view/ directory with one
subdirectory for each /use case/, and one .org file for each /scene/
in the use case. Furthermore, it contains a /controller/ directory
with one .el file for each use case, and a /logic/ directory with
(optionally) one .el file for each use case. Each of these directories
contains another file (or subdirectory in the case of /view/) for use
case independent components. The application objects (one file for all
objects of the same class) are stored in the /objects/ directory, the
classes (one file for each class) in the /objects/classes/
subdirectory. 

* Application Design
  :PROPERTIES:
  :CUSTOM_ID: appl-design
  :END:
** Locally Refining the Software Architecture
   :PROPERTIES:
   :CUSTOM_ID: loc-ref-softw-arch
   :END:

Once the software architecture is defined, application design is only
about locally refining the architecture. Therefore, the
transformations described in the following subsections do not alter
the architecture anymore, but rather map the artefacts from the
software specification to (locally refined) components of the
architecture.

** Implementation Skeletons as Design Artefacts
   :PROPERTIES:
   :CUSTOM_ID: impl-skel-as-design-artefacts
   :END:

Since the iOrg framework only reuses some of the ideas of
object-orientation, but is not really based on an object-oriented
programming language and environment, we cannot produce an application
class model as final UML output of the software design phase (that is
then implemented in an object-oriented language). Therefore we skip
this last step of UML modeling and transform the UML diagrams of the
software specification directly into implementation skeletons, i.e.
into .el (and .org files) with all function signatures (and outline tree
entries) needed to implement the application. The implementation phase
then mainly consists in writing the bodies of the Emacs Lisp functions
(as well as helper functions) that read and manipulate the Org files
of the application.

** The Transformation Rules
   :PROPERTIES:
   :CUSTOM_ID: transform-rules
   :END:
*** General Considerations
    :PROPERTIES:
    :CUSTOM_ID: transform-general-consid
    :END:
Emacs Lisp is not an object-oriented programming language, and the
whole Emacs environment and philosophy is based on functions, not on
objects. However, we used object-oriented terminology throughout this
tutorial. Why did we do that, and how can we map the object-oriented
concepts and terms into the Emacs and Org-mode world? 

Modeling a real world system in terms of objects is convenient,
because the real world is composed of interacting and related objects
(that's at least how humans perceive it). Since the object-oriented
approach has enjoyed the status of a quasi industry standard in the
last decades, there exist well established methodology one can rely on
when modeling a web application in terms of classes and objects.

However, the resulting artefacts of the object-oriented requirements
analysis and software specification must be transformed into a
software design that fits with the language and runtime environment
the system will be implemented in. Some creativity and a lot of
pragmatism is necessary to benefit from such a transformation without
complicating things unnecessary.

While the specific transformation rules will be described in the
following subsections, the following statement holds in general for
the iOrg framework:

#+begin_quote
Terminology from the object-oriented world is used in a very loose and
broad sense in the iOrg framework. When talking about classes,
objects, methods, inheritance etc, we do not talk about those well
defined language constructs and concepts known from /Smalltalk/ and
its successors, but rather about some artefacts from the Emacs and Org-mode
world that might serve to implement some of the ideas associated with
object-orientation. 
#+end_quote

*** Transforming the Domain Class Model
    :PROPERTIES:
    :CUSTOM_ID: transform-dom-class-mod
    :END:

**** Classes, Objects and Inheritance
     :PROPERTIES:
     :CUSTOM_ID: class-obj-inherit
     :END:

The /domain class model/ of the requirements analysis and the software
specification phase is very similar to an /entity-relationship/ model,
because classes (entities) and their relationships are modeled (with
attributes, but without methods).
 
What is a class and and what is an object in the context of the iOrg
framework? How are the relationships between objects implemented?

We define as a convention that each class is represented by one
=/objects/classes/<<class-name>>-class.org= file. New objects of the
class are instantiated as top-level entries in a
=/objects/<<class-name>>-obj.org= file by collecting all attributes
(except the obligatory :super: attribute) of the class and all of its
superclasses, inserting them into the objects attribute drawer, and
assigning new values to them.

Relations with other objects (other than inheritance) are realized via
attribute values, i.e. other objects can represent valid values of
certain object attributes.

As an example for the iOrg object system, let us consider the user
hierarchy of bugpile. There are three types of users, /user/,
/assignee/ and /admin/. Since a bugtracker should make it easy to
participate in improving software, only minimal information is asked
for in the registration process (nickname and email). But for the sake
of this example, lets assume we want to know the public-key of each
assignee and additionally the full name and postal adress of each
admin.

Furthermore, the three user types should differ in what they are
allowed to do in the system, i.e. in their permissions. Following
the example of well-established software systems, we don't hardcode
the permissions into the users, but rather define /roles/ with
certain /permissions/ and then assign the /users/ to one or more roles.

The next graphic shows the inheritance relation between bugpile users
in a very schematic way:

#+srcname bugpile-users
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/bugpile-users.png 
  title \n<b>Bugpile Users</b>

  :User: 
  :Assignee: 
  :Admin: 

  User <|-down- Assignee
  Assignee <|-down- Admin
#+end_src

#+results:
[[file:../../../../images/gsoc/2012/bugpile/bugpile-users.png]]


This schematic relation between users can be translated into the
following class model:

#+srcname bugpile-users-example-class-model
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/bugpile-users-example-class-model.png 
  title Bugpile Users 
  User : nickname\nemail\nroles
  Assignee : public-key
  Admin : surname\nname\nstreet\nhouse-number\npostal-code\ncity\ncountry
  User <|-- Assignee
  Assignee <|-- Admin
#+end_src
 
The relationship between users, roles and permissions can be modeled
like this: 

#+srcname bugpile-users-roles-class-model
#+begin_src plantuml :file ../../../../images/gsoc/2012/bugpile/bugpile-users-roles-class-model.png 
  title Bugpile Users & Roles
  User : nickname\nemail
  Role : name
  Permission : name\nallowed
  User "             0..*" -down- "1..*           " Role
  Role "1..*" -left- "1..*" Permission
#+end_src


To transform these class diagrams into Org files we need one
=/objects/classes/<<class-name>>-class.org= file for each class:

#+begin_src org :exports source
  ,# class /objects/classes/user-class.org
  ,* user
  ,  :PROPERTIES:
  ,  :super:    root
  ,  :nickname:     nil
  ,  :email:    nil
  ,  :roles:    nil
  ,  :END:
#+end_src

#+begin_src org :exports source
  ,# class /objects/classes/assignee-class.org
  , * assignee
  ,  :PROPERTIES:
  ,  :super:    user
  ,  :public-key: nil
  ,  :END:
#+end_src

#+begin_src org :exports source
  ,# class /objects/classes/admin-class.org
  ,* admin
  ,  :PROPERTIES:
  ,  :super:    assignee
  ,  :surname:  nil
  ,  :name:     nil
  ,  :street:   nil
  ,  :house-number: nil
  ,  :postal-code: nil
  ,  :city:     nil
  ,  :country:  nil
  ,  :END:
#+end_src

#+begin_src org :exports source
  ,# class /objects/classes/role-class.org
  ,* role
  ,  :PROPERTIES:
  ,  :super:    root
  ,  :name:     nil
  ,  :permissions: nil
  ,  :END:
#+end_src


#+begin_src org :exports source
  ,# class /objects/classes/permission-class.org
  ,* permission
  ,  :PROPERTIES:
  ,  :super:   root
  ,  :name:     nil
  ,  :allowed:  nil
  ,  :END:
#+end_src


If we want to instantiate objects of these classes, we have to create a
=/objects/<<class-name>>-obj.org= file for each of them and add
one top-level entry for every newly instantiated object. The object
attributes are collected from the instantiated class itself and all
its superclasses. 

#+begin_src org :exports source
  ,# object /objects/user-obj.org
  ,* user
  ,  :PROPERTIES:
  ,  :nickname:     henry
  ,  :email:    henry@special.com
  ,  :roles:    user
  ,  :END:
  ,* user
  ,  :PROPERTIES:
  ,  :nickname:     harry
  ,  :email:    harry@royal.com
  ,  :roles:    user
  ,  :END:
#+end_src

#+begin_src org :exports source
  ,# object /objects/assignee-obj.org
  ,* assignee
  ,  :PROPERTIES:
  ,  :nickname:     joe
  ,  :email:    joe@average.com
  ,  :roles:    assignee
  ,  :public-key: 42A17BR55
  ,  :END:
  ,* assignee
  ,  :PROPERTIES:
  ,  :nickname:     john
  ,  :email:    john@handsome.com
  ,  :roles:    assignee
  ,  :public-key: 43G8529FA
  ,  :END:
#+end_src


#+begin_src org :exports source
  ,# object /objects/admin-obj.org
  ,* admin
  ,  :PROPERTIES:
  ,  :nickname:     bob13
  ,  :email:    bob@system.com
  ,  :roles:    admin
  ,  :public-key: 826AFAF35FGA
  ,  :surname:  bob
  ,  :name:     smith
  ,  :street:   flowerstreet
  ,  :house-number: 12
  ,  :postal-code: 1200
  ,  :city:     fresno
  ,  :country:  usa
  ,  :END:
  ,* admin
  ,  :PROPERTIES:
  ,  :nickname:    hans369
  ,  :email:    hans@admin.com
  ,  :roles:    admin
  ,  :public-key: SF351AGAG
  ,  :surname:  hans
  ,  :name:     schmidt
  ,  :street:   hansastrasse
  ,  :house-number: 33
  ,  :postal-code: 12456
  ,  :city:     berlin
  ,  :country:  germany
  ,  :END:
  
#+end_src

#+begin_src org :exports source
  ,# object /objects/role-obj.org
  ,* role
  ,  :PROPERTIES:
  ,  :name:     user
  ,  :permissions: rest
  ,  :END:
  ,* role
  ,  :PROPERTIES:
  ,  :name:    assignee
  ,  :permissions: tasks 
  ,  :END:
  ,* role
  ,  :PROPERTIES:
  ,  :name:     admin
  ,  :permissions: tasks projects users
  ,  :END:
#+end_src


#+begin_src org :exports source
  ,# object /objects/permission-obj.org
  ,* permission
  ,  :PROPERTIES:
  ,  :name:     rest
  ,  :allowed: unpriviledged
  ,  :END:
  ,* permission
  ,  :PROPERTIES:
  ,  :name:     tasks
  ,  :allowed:  open-new-task take-action-on-selected-tasks edit-task
  ,  :END:
  ,* permission
  ,  :PROPERTIES:
  ,  :name:     projects
  ,  :allowed: create-project edit-project
  ,  :END:
  ,* permission
  ,  :PROPERTIES:
  ,  :name:     users
  ,  :allowed:  search-users take-action-on-selected-users
  ,  :END:
#+end_src

*** Transforming Software Oriented Activities (SOA)
    :PROPERTIES:
    :CUSTOM_ID: transform-rules-soa
    :END:
We used software oriented activity diagrams for integrated modeling of
user activities and the related UI. Thus, these diagrams need to be
transformed into the /controller/, /view/ and /logic/ component of the
iOrg framework.

Each activitiy diagram (use case) is transformed into one
=<<use-case-name>>-controller.el= file in the /controller/ directory
(e.g. =open-new-task-controller.el=). For each system activitiy in the
SOA, one handler function is added to this controller file (e.g.
=show-open-new-task-form-handler(...)= and
=store-new-task-handler(...)=). 

Each /scene/ in the SOA is translated into one
=<<user-activity-name>>-scene.org= file in the use case subdirectory
of the /view/ directory (e.g. =define-user-search-criteria-scene.org=
in the /view/search-users/ directory). 
 
*** Transforming Complex System Activities
    :PROPERTIES:
    :CUSTOM_ID: transform-complex-syst-act
    :END:

If there is complex logic involved in a use case (a system activity
marked with the pitchfork symbol ⋔ as subactivity in a SOA), a
=<<use-case-name>>-logic.el= file is added to the /logic/ directory
(e.g. =search-task-list-logic.el=). The 'atomic' system activities
that constitute the complex system activitiy are translated into
worker functions in this file (e.g. =search-task-worker(...)= and
=prepare-result-list-worker(...)=).

The /worker/ functions from the /logic/ component are independent of
the client used, they represent basic application functionality needed
when accesssing the application from a web-browser as well as directly
from Emacs. The /handler/ functions from the /controller/ component
are only used by the web-client, their sole razon d'etre is the
handling of http requests. The application should still work without
them, if accessed directly from Emacs. 

Thus, /handler/ functions are a bit like managers - there are many of
them and they need a lot of attention, but things still work without
them (accesssing the application from Emacs). They don't do the real
work, they just coordinate and manage things with regards to the
web-clients. On the other hand, /worker/ functions are more like
engineers, they do the hard work in the background, and without them
the system does not work anymore.

# **** Search Tasks
#     :PROPERTIES:
#     :CUSTOM_ID: search-tasks-syst-act-design
#     :END:

# Since bugpile uses a dVCS as database for its textfiles, a query for a
# task might include task name, commit (date or id), author, state of
# the task, and other information that can't be accessed simply by
# searching for the task file in the file system. The search
# facilities should be available independently from the frontend used,
# i.e. power users might use them from Emacs just as normal users from
# their web browser.  Therefore, bugpile should use the underlying dVCS
# to do most of the 'heavy lifting' in processing user queries and then
# prepare the result set according to the frontend used.   

# **** Search Users
#     :PROPERTIES:
#     :CUSTOM_ID: search-users-syst-act-design
#     :END:

# In contrast to tasks, users are relatively static entities in the bugpile
# system, thus it seems unnecessary to rely on the underlying dVCS to answer
# queries about users, Emacs and Org-mode functionality should
# sufficice. 


*** Summary of Transformation Rules
    :PROPERTIES:
    :CUSTOM_ID: summary-transform-rules
    :END:

The following tables summarize the transformation rules that
transform the results (artefacts) of the software specification into
the software design. 

Software oriented activities (SOAs) are transformed with the following
rules:

| Software Oriented Activity (SOA) | mapping => software design     |
|--------------------------------+--------------------------------|
| <30>                           | <30>                           |
| use case (SOA diagram)         | /controller/USE-CASE-NAME-controller.el file |
| use case (SOA diagram)         | /view/USE-CASE-NAME subdirectory |
| use case with complex logic    | /logic/USE-CASE-NAME-logic.el file |
| system activity (SA)           | SYSTEM-ACTIVITY-NAME-handler(...) function in controller file |
| scene                          | USER-ACTIVITY-NAME-scene.org file in /view/USE-CASE-NAME subdirectory |
| start-node use case (SOA diagram) | start-USE-CASE-NAME-handler(...) function in controller file |
| end-node use case (SOA diagram) | end-USE-CASE-NAME-handler(...) function in controller file |

Complex system activities are transformed with the following
rule:  

| Complex System Activity        | mapping => software design     |
|--------------------------------+--------------------------------|
| <30>                           | <30>                           |
| 'atomic' system activity (SA)  | SYSTEM-ACTIVITY-NAME-worker(...) function in logic file |


The domain class model is transformed with the following
rules: 

| Domain Class Model             | mapping => software design     |
|--------------------------------+--------------------------------|
| <30>                           | <30>                           |
| class                          | /objects/classes/CLASS-NAME-class.org file with one top-level entry '* CLASS-NAME' with one attribute drawer |
| attribute                      | :attribute: DEFAULT-VALUE in the class attribute drawer |
| (multiple) inheritance         | superclass name(s) as value(s) of the :super: attribute in the class property drawer |
| composition                    | object name(s) as value(s) of another objects attribute in the attribute drawer |
| object                         | /objects/CLASS-NAME-obj.org file with one top-level entry for each instantiated object of CLASS-NAME |

*** Programming the Transformations
    :PROPERTIES:
    :CUSTOM_ID: programming-transformations
    :END:

The transformation of the software specification UML diagrams into the
.org and .el files of the software design can easily be done manually.
But the fact that our UML drawing tool /plantuml/ is text based enables
us to parse the source code of our UML diagrams. Since the
transformation rules are well defined and operational, we can program
the transformation process and avoid a lot of tedious manual work. 

Of course, the automatic transformation only works if the source code
of the plantuml diagrams strictly adheres to the conventions and
abbreviations used in this tutorial.

* Implementation
   :PROPERTIES:
   :CUSTOM_ID: implementation
   :END:
** Implementing the Worker Functions
   :PROPERTIES:
   :CUSTOM_ID: impl-worker-funct
   :END:
** Implementing the Handler Functions
   :PROPERTIES:
   :CUSTOM_ID: impl-handler-funct
   :END:
*** URL-Map and Dispatcher
    :PROPERTIES:
    :CUSTOM_ID: url-map-dispatcher
    :END:
The applications url-map and dispatcher-handler can be produced
programmatically. 

*** Initializing and Finishing Uses Cases
    :PROPERTIES:
    :CUSTOM_ID: init-and-finish-use-cases
    :END:

At the start and at the end of each use case special =start= and =end=
functions are called that initialize the use case, check the pre- and
postconditions, and clean up if necessary. 

*** Handling Http-Requests
    :PROPERTIES:
    :CUSTOM_ID: handling-http-requests
    :END:

The core duty of /handler/ functions is the handling of http-requests
from the web-client. 
 
** Implementing the View Files
   :PROPERTIES:
   :CUSTOM_ID: impl-view-files
   :END:

* Verification
  :PROPERTIES:
  :CUSTOM_ID: verification
  :END:

